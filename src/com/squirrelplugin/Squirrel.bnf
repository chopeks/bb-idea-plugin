{
  parserClass="com.squirrelplugin.parser.SquirrelParser"
  parserUtilClass="com.squirrelplugin.parser.SquirrelParserUtil"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Squirrel"
  psiImplClassSuffix="Impl"
  psiPackage="com.squirrelplugin.psi"
  psiImplPackage="com.squirrelplugin.psi.impl"

  elementTypeHolderClass="com.squirrelplugin.psi.SquirrelTypes"
  elementTypeClass="com.squirrelplugin.psi.SquirrelElementType"
  tokenTypeClass="com.squirrelplugin.psi.SquirrelTokenType"

  tokens = [
    SEMICOLON_SYNTHETIC  =  '<NL>'

    RBRACE               =  '}'
    RBRACK               =  ']'
    RPAREN               =  ')'
    INCREMENT            =  '++'
    DECREMENT            =  '--'

    LBRACE               =  '{'
    LBRACK               =  '['
    LPAREN               =  '('
    DOUBLE_COLON         =  '::'
    COLON                =  ':'
    SEMICOLON            =  ';'
    COMMA                =  ','
    MULTI_ARGS           =  '...'
    CLASS_ATTR_START     =  '</'
    CLASS_ATTR_END       =  '/>'
    SHIFT_LEFT           =  '<<'
    SHIFT_RIGHT          =  '>>'
    UNSIGNED_SHIFT_RIGHT =  '>>>'
    CMP                  =  '<=>'
    EQ                   =  '=='
    NOT_EQ               =  '!='
    LESS_OR_EQUAL        =  '<='
    GREATER_OR_EQUAL     =  '>='
    SEND_CHANNEL         =  '<-'
    PLUS_ASSIGN          =  '+='
    MINUS_ASSIGN         =  '-='
    MUL_ASSIGN           =  '*='
    QUOTIENT_ASSIGN      =  '/='
    REMAINDER_ASSIGN     =  '%='
    COND_OR              =  '||'
    COND_AND             =  '&&'
    ASSIGN               =  '='
    NOT                  =  '!'
    BIT_NOT              =  '~'
    BIT_OR               =  '|'
    BIT_XOR              =  '^'
    BIT_AND              =  '&'
    LESS                 =  '<'
    GREATER              =  '>'
    PLUS                 =  '+'
    MINUS                =  '-'
    MUL                  =  '*'
    QUOTIENT             =  '/'
    REMAINDER            =  '%'
    QUESTION             =  '?'
    AT                   =  '@'
    PERIOD               =  '.'

    LINE_COMMENT = "regexp:(//|#)[^\r\n]*"
    BLOCK_COMMENT = "regexp:/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*(\*+/)"

    IDENTIFIER = "regexp:[a-zA-Z_]+[a-zA-Z_0-9]*"
    INT = "regexp:((0[1-9][0-7]*)|(0x[0-9a-fA-F]*)|('\p{Alpha}')|(0|([1-9][0-9]*)))"
    FLOAT = "regexp:((([0-9]+\.[0-9]*)|([0-9]*\.[0-9]+))([eE][+-]?[0-9]+)?)|([0-9]+([eE][+-]?[0-9]+))"
    STRING = "regexp:(@\"([^\"]|\"\")*\"|\"(\\.|[^\"\n\r])*\")"

    NL="NL"
    WS="WS"
    NL="regexp:[\r\n]|\r\n"
    WS="regexp:[ \t\f]"
  ]

  extends(".*Expression")=Expression
  extends(".*Statement")=Statement
  name(".*Expression")="expression"
}

// ---------
// PREVIEW MODE GOTCHAS
// ---------
// The optional semicolon logic is placed inside lexer. Therefore in order to test stuff in preview mode, you should
// keep in mind that:
//
// 1. In the preview mode, you should use <NL> instead of new lines in cases where you want the new line to work as
// semicolon. This is a fix for a live preview feature where it can't distinguish between whitespace line breaks and the
// useful ones.
//
// 2. Also, you should put semicolons after } in places where you expect the virtual semicolon to be placed.

//// TEST DATA:
//
//i = 2;
//i = 02;
//i = 0x222;
//i = 'c';
//f = 0.52;
//f = 1.e2;
//f = 1.e-2;
//s = "I'm a string"<NL>
//s = @"I'm a string verbatim string"<NL>
//s = @"I'm a multiline
//string verbatim string"<NL>
//b = true;
//b = false;
//n = null;
//exp = a ? i + 2 : b > -3 + +23 * i++ / 34 % ~ 3
//nc = i++ + ++i - --i - i-- + +i - -i - -(-i) + -i-- + errors_on_right + ---i + --(-i) + --i--i
//
//const a=-2;
//const b=2;
//enum c {};
//enum c {a,b,c=4, h="23", h=23, h=-2};
//local o, a=2, b=23, c = (1,2), d = function(a,b=2,c=2){}, e = @(a,b,...) a + (b, f = 2), g=[123, function(){}, @()(1+2)], c = class {};
//function a(a, b, a=2, a=2) {};
//a(a, 2, g[1]);
//class Test.B extends Test {
//    constructor (a) {
//    }
//    a = function (asd){
//    }
//    function sds() {
//    }
//    g = "234"
//}

SquirrelFile ::= !<<eof>> Statements

private semi ::= '<NL>' | ';' {name="semicolon"}
private multisemi ::= semi+ {name="semicolon"}
private delimiter ::= multisemi | &'}' | <<eof>> | <<previousBrace>>

private Statements ::= multisemi? StatementWithSemi*

private StatementWithSemi ::= Statement delimiter { pin=1 recoverWhile=statement_recover }

private statement_recover ::= !(<<eof>> | delimiter | '{' | '}' | const | enum | local | function | class | return | break | continue | yield | throw | for | foreach | while | do | if | else | switch | case | default | try | catch)

Statement ::=
    Block
    | Expression
    | ConstDeclarationStatement
    | EnumDeclarationStatement
    | LocalDeclarationStatement
    | FunctionDeclarationStatement
    | ClassDeclarationStatement

    | ReturnStatement
    | BreakStatement
    | ContinueStatement
    | YieldStatement
    | ThrowStatement

    | ForLoopStatement
    | ForEachLoopStatement
    | WhileLoopStatement
    | DoWhileLoopStatement
    | IfConditionalStatement
    | SwitchConditionalStatement
    | TryCatchStatement

private StatementOrEmpty ::= Statement | ';'

Block ::= '{' Statements? '}' {pin=1}

ConstDeclarationStatement ::= const Id '=' Literal {pin=1}

EnumDeclarationStatement ::= enum Id '{' EnumItemDeclarations? '}' {pin=1}
private EnumItemDeclarations ::= EnumItemDeclaration (',' EnumItemDeclaration)* ','?
EnumItemDeclaration ::= Id [ '=' Literal ]

LocalDeclarationStatement ::= local VariableOrFunctionDeclarations {pin=1}
private VariableOrFunctionDeclarations ::= VarDeclarations | FunctionDeclaration { name="variable or function declarations" }
private VarDeclarations ::= VarDeclaration (',' VarDeclaration)*
VarDeclaration ::= Id [ '=' ExpressionWithNoComma ]

FunctionDeclarationStatement ::= FunctionDeclaration
private FunctionDeclaration ::= function FunctionName FunctionParametersAndBody  {pin=1}
FunctionName ::= Id ('::' (Id | constructor))*
private FunctionParametersAndBody ::= FunctionParameters StatementOrEmpty

FunctionParameters ::=
'(' FunctionParameter (',' FunctionParameter)* ((',' FunctionDefaultParameter)+ | (',' FunctionVariableNumberParameter))? ')'
| '(' FunctionDefaultParameter (',' FunctionDefaultParameter)* ')'
| '(' FunctionVariableNumberParameter? ')'

FunctionParameter ::= Id (!'=')
FunctionDefaultParameter ::= Id '=' ExpressionWithNoComma
FunctionVariableNumberParameter ::= '...'

ClassDeclarationStatement ::= class ClassName [extends ClassName] ClassBody {pin=1}
ClassName ::= Id ('.' Id)*
private ClassBody ::= '{' ClassMembers? '}'
private ClassMembers ::= ClassMember (semi* ClassMember)* semi?
ClassMember ::= ClassAttribute? static? (ConstructorDeclaration | RegularClassMember)
private RegularClassMember ::= KeyValuePair | FunctionDeclaration
ConstructorDeclaration ::= constructor FunctionParametersAndBody
ClassAttribute ::= '</' KeyValuePairs? '/>'

ReturnStatement ::= return Expression? {pin=1}
BreakStatement ::= break
ContinueStatement ::= continue
YieldStatement ::= yield Expression {pin=1}
ThrowStatement ::= throw Expression {pin=1}

ForLoopStatement ::= for ForLoopPartsInBraces StatementOrEmpty {pin=1}

ForLoopPartsInBraces::= '(' ForLoopParts ')'
ForLoopParts::= [LocalDeclarationStatement | Expression] ';' Expression? ';' Expression?

ForEachLoopStatement ::= foreach '(' [Id ','] Id in Expression ')' StatementOrEmpty {pin=1}
WhileLoopStatement ::= while '(' ExpressionWithRecoverUntilParen ')' StatementOrEmpty {pin=1}
DoWhileLoopStatement ::= do StatementOrEmpty while '(' ExpressionWithRecoverUntilParen ')' {pin=1}
IfConditionalStatement ::= if '(' ExpressionWithRecoverUntilParen ')' StatementOrEmpty [semi? else StatementOrEmpty] {pin=1}

SwitchConditionalStatement ::= switch '(' ExpressionWithRecoverUntilParen ')' '{' SwitchCase* DefaultCase? '}' {pin=1}
SwitchCase ::= case Expression ':' Statements? {pin=1}
DefaultCase::= default ':' Statements? {pin=2}

TryCatchStatement ::= try StatementOrEmpty catch '(' Id ')' StatementOrEmpty {pin=1}

private ExpressionWithRecoverUntilParen ::= Expression {recoverWhile=parenthesesRecovery}
private parenthesesRecovery ::= !')'

Expression ::=
  CommaExpression
  | AssignExpression
  | ElvisExpression
  | OrExpression
  | second_expr_group
  | BitOrExpression
  | BitXorExpression
  | BitAndExpression
  | CompareExpression
  | LessGreaterEqualExpression
  | BitShiftExpression
  | PlusMinusExpression
  | MulDivModExpression
  | first_expr_group
  | c_expr_group
  | b_expr_group
  | a_expr_group

private ExpressionWithNoComma ::=
  AssignExpression
  | ElvisExpression
  | OrExpression
  | second_expr_group
  | BitOrExpression
  | BitXorExpression
  | BitAndExpression
  | CompareExpression
  | LessGreaterEqualExpression
  | BitShiftExpression
  | PlusMinusExpression
  | MulDivModExpression
  | first_expr_group
  | c_expr_group
  | b_expr_group
  | a_expr_group {name="expression"}

private a_expr_group ::= (SimpleRefExpression | LiteralExpression | ParenExpression)
private b_expr_group ::= (ArrayItemExpression | RefExpression | FunctionCallExpression)
private c_expr_group ::= (ClassExpression | TableExpression | ArrayExpression | FunctionExpression | LambdaFunctionExpression )
private first_expr_group ::= (UnaryExpression | PreIncrementExpression | InstanceOfExpression )
private second_expr_group ::= (AndExpression | InExpression)

CommaExpression ::= Expression ',' Expression
AssignExpression ::= Expression ('=' | '<-' | '*=' | '/=' | '%=' | '+=' | '-=' ) Expression { rightAssociative=true }
ElvisExpression ::= Expression '?' Expression ':' Expression
OrExpression ::= Expression '||' Expression
AndExpression ::= Expression '&&' Expression
InExpression ::= Expression in Expression
BitOrExpression ::= Expression '|' Expression
BitXorExpression ::= Expression '^' Expression
BitAndExpression ::= Expression '&' Expression
CompareExpression ::= Expression ('==' | '!=' | '<=>' ) Expression
LessGreaterEqualExpression ::= Expression ('<' | '<=' | '>' | '>=' ) Expression
BitShiftExpression ::= Expression ('<<' | '>>' | '>>>') Expression
PlusMinusExpression ::= Expression ( '+' | '-') Expression
MulDivModExpression ::= Expression ('*' | '/' | '%') Expression
UnaryExpression ::= ('-' | '!' | '~' | typeof | clone | delete | resume) Expression
PreIncrementExpression ::= ('++' | '--') NamedElementExpression
InstanceOfExpression ::= Expression instanceof Expression
ParenExpression ::= '(' Expression ')'
ClassExpression ::= class [extends ClassName] ClassBody
FunctionExpression ::= function FunctionParametersAndBody
LambdaFunctionExpression ::= '@' FunctionParameters ExpressionWithNoComma
FunctionCallExpression ::= Expression FunctionArguments
FunctionArguments ::= '(' ')' | '(' FunctionArgument (',' FunctionArgument)* ')'
FunctionArgument ::= ExpressionWithNoComma

ArrayExpression ::= '[' ArrayElements?  ']'
private ArrayElements ::= ExpressionWithNoComma (',' ExpressionWithNoComma)* ','?

ArrayItemExpression ::= Expression '[' ExpressionWithNoComma ']' ['++' | '--']

TableExpression ::= '{' KeyValuePairs? '}'
private TableItemSeparator ::= ',' | '<NL>'
private KeyValuePairs ::= TableItem (TableItemSeparator* TableItem)* TableItemSeparator?
TableItem ::= KeyValuePair | FunctionDeclaration
private KeyValuePair ::= Key '=' ExpressionWithNoComma
Key ::= Id | '[' Expression ']'

private NamedElementExpression ::= SimpleRefExpression | RefExpression | ArrayItemExpression
RefExpression ::= Expression '.' (Id | constructor)

SimpleRefExpression ::= Id ['++' | '--'] {elementType=RefExpression}
LiteralExpression ::= Literal

Literal ::=
    '-'? INT
  | '-'? FLOAT
  | STRING
  | true | false
  | null

Id ::= '::'? IDENTIFIER { name="identifier" }
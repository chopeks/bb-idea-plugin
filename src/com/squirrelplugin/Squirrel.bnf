{
  parserClass="com.squirrelplugin.parser.SquirrelParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Squirrel"
  psiImplClassSuffix="Impl"
  psiPackage="com.squirrelplugin.psi"
  psiImplPackage="com.squirrelplugin.psi.impl"

  elementTypeHolderClass="com.squirrelplugin.psi.SquirrelTypes"
  elementTypeClass="com.squirrelplugin.psi.SquirrelElementType"
  tokenTypeClass="com.squirrelplugin.psi.SquirrelTokenType"

  tokens = [
    SEMICOLON_SYNTHETIC  =  '<NL>'

    RBRACE               =  '}'
    RBRACK               =  ']'
    RPAREN               =  ')'
    PLUS_PLUS            =  '++'
    MINUS_MINUS          =  '--'

    LBRACE               =  '{'
    LBRACK               =  '['
    LPAREN               =  '('
    COLON                =  ':'
    DOUBLE_COLON         =  '::'
    SEMICOLON            =  ';'
    COMMA                =  ','
    ASSIGN               =  '='
    SEND_CHANNEL         =  '<-'
    EQ                   =  '=='
    NOT_EQ               =  '!='
    CMP                  =  '<=>'
    NOT                  =  '!'
    COND_OR              =  '||'
    COND_AND             =  '&&'
    BIT_OR               =  '|'
    BIT_XOR              =  '^'
    BIT_AND              =  '&'
    LESS                 =  '<'
    LESS_OR_EQUAL        =  '<='
    GREATER_OR_EQUAL     =  '>='
    GREATER              =  '>'
    SHIFT_LEFT           =  '<<'
    SHIFT_RIGHT          =  '>>'
    UNSIGNED_SHIFT_RIGHT =  '>>>'
    PLUS_ASSIGN          =  '+='
    PLUS                 =  '+'
    MINUS_ASSIGN         =  '-='
    MINUS                =  '-'
    MUL                  =  '*'
    QUOTIENT             =  '/'
    REMAINDER            =  '%'

    LINE_COMMENT = "regexp:(//|#)[^\r\n]*"
    BLOCK_COMMENT = "regexp:/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*(\*+/)"

    IDENTIFIER = "regexp:\p{Alpha}\w*"
    INT = "regexp:((0[1-9][0-7]*)|(0x[0-9a-fA-F]*)|('\p{Alpha}')|(0|([1-9][0-9]*)))"
    FLOAT = "regexp:((([0-9]+\.[0-9]*)|([0-9]*\.[0-9]+))([eE][+-]?[0-9]+)?)|([0-9]+([eE][+-]?[0-9]+))"
    STRING = "regexp:(@\"([^\"]|\"\")*\"|\"(\\.|[^\"\n\r])*\")"

    NL="regexp:[\r\n]|\r\n"
    WS="regexp:[ \t\f]"
  ]

  extends(".*Expr")=Expr
}

// ---------
// NOTE:
// ---------
// In the preview mode, you should use <NL> instead of new lines in cases where you want the new line to work as
// semicolon. This is a fix for a live preview feature where it can't distinguish between whitespace line breaks and the
// useful ones.

//// TEST DATA:
//
//i = 2;
//i = 02;
//i = 0x222;
//i = 'c';
//f = 0.52;
//f = 1.e2;
//f = 1.e-2;
//s = "I'm a string"<NL>
//s = @"I'm a string verbatim string"<NL>
//s = @"I'm a multiline
//string verbatim string"<NL>
//b = true;
//b = false;
//n = null;

SquirrelFile ::= StatementList <<eof>> {pin(".*")=1}

StatementWithoutSemi ::=
    LINE_COMMENT
    | BLOCK_COMMENT
    | FunctionDeclaration
    | Block

StatementsWithSemi ::=
    Expr
    | ConstDeclaration
    | LocalVarDeclaration

private semi ::= SEMICOLON_SYNTHETIC | SEMICOLON
private SingleStatement ::= (StatementsWithSemi | StatementWithoutSemi)
private StatementList ::= (StatementWithoutSemi semi* StatementList | StatementsWithSemi semi+ StatementList | SingleStatement) semi*

Block ::= LBRACE (RBRACE | StatementList RBRACE)

ConstDeclaration ::= const IDENTIFIER ASSIGN Literal


LocalVarDeclaration ::= local VarDeclaration
VarDeclaration ::= IDENTIFIER [ ASSIGN Expr ][ COMMA VarDeclaration ]



FunctionDeclaration ::= function FunctionName Block?
FunctionName ::= IDENTIFIER (DOUBLE_COLON IDENTIFIER)?


Expr ::= CommaExpr
  | AssignExpr
  | ElvisExpr
  | OrExpr
  | (AndExpr | InExpr)
  | BitOrExpr
  | BitXorExpr
  | BitAndExpr
  | CompareExpr
  | LessGreaterEqualExpr
  | BitShiftExpr
  | PlusMinusExpr
  | MulDivModExpr
  | (UnaryExpr/*| InstanceOfExp | PlusPlusExp */ )
  | RefExpr
  | (SimpleRefExpr | LiteralExpr | ParenExpr)

CommaExpr ::= Expr ',' Expr
AssignExpr ::= Expr ('=' | '<-' | '*=' | '/=' | '%=' | '+=' | '-=' ) Expr { rightAssociative=true }
ElvisExpr ::= Expr '?' Expr ':' Expr
OrExpr ::= Expr '||' Expr
AndExpr ::= Expr '&&' Expr
InExpr ::= Expr in Expr
BitOrExpr ::= Expr '|' Expr
BitXorExpr ::= Expr '^' Expr
BitAndExpr ::= Expr '&' Expr
CompareExpr ::= Expr ('==' | '!=' | '<=>' ) Expr
LessGreaterEqualExpr ::= Expr ('<' | '<=' | '>' | '>=' ) Expr
BitShiftExpr ::= Expr ('<<' | '>>' | '>>>') Expr
PlusMinusExpr ::= Expr ( '+' | '-') Expr
MulDivModExpr ::= Expr ('*' | '/' | '%') Expr
UnaryExpr ::= ('-' | '+' | '!' | '~' | typeof) Expr
//PlusPlusExp ::= Expr ( '++' | '--') // TODO a++ ++a
//InstanceOfExp ::= Expr instanceof Expr
ParenExpr ::= '(' Expr ')'

SimpleRefExpr ::= IDENTIFIER {elementType=RefExpr}
RefExpr ::= Expr '.' IDENTIFIER
LiteralExpr ::= Literal

Literal ::=
    INT
  | FLOAT
  | STRING
  | true | false
  | null
